---
title: "Studying Python"
output: html_document
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float: yes
    highlight: zenburn
    code_download: true
    includes:
      in_header: header.html
---

`enumerate()` is a generator that returns a running index as well as the actual element or item in the container. Optinal argument includes the start parameter (number the index should start at)

```{python}
list(enumerate([1,2,3]))
```

```{python}
list(enumerate(range(3), start=10))
```

**Fizz Buzz**

Write a program that prints the numbers from 1 to 100 and for multiples of '3' print “Fizz” instead of the number and for the multiples of '5' print “Buzz”.

```{python}
for i in range(1,101):
  if i % 3 == 0:
    if i % 5 == 0:
      print('Fizz Buzz')
      continue
    print('Fizz')
    continue
  if i % 5 == 0:
    if i % 3 == 0:
      print('Fizz Buzz')
      continue
    print('Buzz')
    continue
  else:
    print(i)

```

Write a program with the same requirements as above but mutates a list, not prints it. 
Use if and elif to not mutate the list so many times. 

```{python}
def fizz_buzz(numbers):
  '''
  Given a list of integers:
  1. replace all integers that are evenly divisible by 3 with 'fizz'
  2. replace all integers divisible by 5 with 'buzz'
  3. replace all integers divisible by both 3 and 5 with 'fizzbuzz'
  
  >>> numbers = [45, 22, 14, 65, 97, 72]
  >>> fizz_buzz(numbers)
  >>> numbers
  ['fizzbuzz', 22, 14, 'buzz', 97, 'fizz']
  '''
  for i in range(len(numbers)):
    num = numbers[i]
    if num % 3 == 0 and num % 5 == 0:
      numbers[i] = 'fizzbuzz'
    elif num % 3 == 0:
      numbers[i] = 'fizz'
    elif num % 5 == 0:
      numbers[i] = 'buzz'

```

```{python}
numbers = [1,2,3,4,5,6,7,8,9,10,15,45, 22, 14, 65, 97, 72]
fizz_buzz(numbers)
numbers
```
Can also use `enumerate()` instead of range(len()). Difference is that `eumerate()` takes an iterable while range(len()) takes a number.

```{python}
def fizz_buzz(numbers):
  '''
  Given a list of integers:
  1. replace all integers that are evenly divisible by 3 with 'fizz'
  2. replace all integers divisible by 5 with 'buzz'
  3. replace all integers divisible by both 3 and 5 with 'fizzbuzz'
  
  >>> numbers = [45, 22, 14, 65, 97, 72]
  >>> fizz_buzz(numbers)
  >>> numbers
  ['fizzbuzz', 22, 14, 'buzz', 97, 'fizz']
  '''
  for i, num in enumerate(numbers):
    num = numbers[i]
    if num % 3 == 0 and num % 5 == 0:
      numbers[i] = 'fizzbuzz'
    elif num % 3 == 0:
      numbers[i] = 'fizz'
    elif num % 5 == 0:
      numbers[i] = 'buzz'

```

```{python}
numbers_1 = list(range(1,101))
fizz_buzz(numbers_1)
numbers_1
```

# Doctest

Doctest is a module that scans the Docstrings of functions looking for lines that look like input and output and uses them to test your function. The Doctest module can be either added into the script or run in concert with the script using command line arguments.

## Adding to the script

```{python eval=FALSE }
if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

## Running from the command line

`python -m doctest -v temp.py`

The `-v` switch will print the tests and results that *Doctest* is running. Without the switch, it will run but not print anything to the console unless there is an error found.

## Examples

```{python eval=FALSE}
def factorial(n):
    """Return the factorial of n, an exact integer >= 0.

    >>> [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> factorial(30)
    265252859812191058636308480000000
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0

    Factorials of floats are OK, but the float must be an exact integer:
    >>> factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    >>> factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    >>> factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """

    import math
    if not n >= 0:
        raise ValueError("n must be >= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor <= n:
        result *= factor
        factor += 1
    return result


if __name__ == "__main__":
    import doctest
    doctest.testmod()

```



# Differences between two lists

When comparing two `lists`, you can convert them into `sets` to eliminate any duplicate numbers. Also, lists can not be operated on using '-' but `sets` can. Lists can however use the '+' which just combines the two `lists` together.

```{python}
list1 = [1,2,3,4]
list2 = [3,3,4,5,6,7,7]
set(list1) - set(list2)
```

```{python}
list1 = [1,2,3,4]
list2 = [3,3,4,5,6,7,7]
set(list2) - set(list1)
```

```{python}
def diff(list1, list2):
  return list(set(list1) - set(list2)) + list(set(list2) - set(list1))
```

```{python}
list1 = [1,2,3,4]
list2 = [3,3,4,5,6,7,7]
diff(list1, list2)
```

Without using `set()` we can use list comprehension

```{python}

def diff2(list1, list2):
	list_dif = [i for i in list1 + list2 if i not in list1 or i not in list2]
	return list_dif
```

```{python}
list1 = [1,2,3,4]
list2 = [3,3,4,5,6,7,7]
list3 = diff2(list1, list2)
print(list3)
```

The difference between `diff()` and `diff2()` is that if you don't convert the `lists` to `sets` then you keep both `7's` in `list2`. 

# Underscore '_'

The underscore can be used to ignore a single value

```{python}

a, _, b = (1, 2, 3) # a = 1, b = 3
print(a, b)
```

It can also be used to ignore multiple values using the *(variable) used to assign multiple value to a variable as list while unpacking it's called "Extended Unpacking", only available in Python 3.x

```{python}
a, *_, b = (7, 6, 5, 4, 3, 2, 1)
print(a, b)
```

# Separating Digits Of Numbers
If you have a long digits number, you can separate the group of digits as you like for better understanding.

`million = 1_000_000`

# List comprehension

```{python}
lst = [1,2,-5,4]

def square(x):
  return x*x

```

Instead of doing the following:

```{python}
list(map(square, lst))
```

You can use list comprehension:
```{python}
[square(num) for num in lst]
```

```{python}
def is_odd(x):
  return x % 2 == 1
```

We can use the `filter()` function to filter out elements of our list according to if they meet certain criteria.

```{python}
list(filter(is_odd, lst))
```

```{python}
[x for x in lst if is_odd(x)]
```
Let's create a 2x3 matrix filled with zeros and define it using lists.

```{python}
grid = [[0,0,0,
       0,0,0]]
```
Using `for` loop

```{python}
num_rows = 2
num_columns = 3
grid = []

for _ in range(num_rows):
  curr_row = []
  for _ in range(num_columns):
    curr_row.append(0)
  grid.append(curr_row)

grid
```

Using *list comprehension*

```{python}
num_rows = 2
num_columns = 3
grid = []

```

```{python}
grid = [[0 for _ in range(num_columns)] for _ in range(num_rows)]
grid
```
Compare the above to this where the brackets are in different places.

```{python}
num_rows = 2
num_columns = 3
grid = []

grid = [[0 for _ in range(num_columns) for _ in range(num_rows)]]
grid
```

```
[] = list
() = tuple
{} = dictionary/set
```
The function `max()` takes in some numbers and returns the max number

```{python}
L = [1,2,3, -4]
t = (1,2,3, -4)
s = {1,2,3, -4}
```
```{python}
max(L)
max(t)
max(s)
max(1,2,3)
max(L, key=lambda x: x*x)

```

`min()` is the same as max but returns the min

`any()` takes in an iterable and returns `True` if any of the values in the iterable are `True` and returns `False` if none of the values are `True`

```{python}
any(L)
```

```{python}
any([False, False])
```

We can't use `any()` to see if any in our list is odd because it does not take arguments to `key`

```{python eval=FALSE}
any(L, key=lambda x: x % 2 == 1)
```

Instead, we have to use list comprehension. You can pass in an argument (num) by adding it after the lambda function.

```{python}
[(lambda x:x % 2 == 1)(num) for num in L]
```

```{python}
any([(lambda x:x % 2 == 1)(num) for num in L])
```
`all()` is the same as `any()` but only returns `True` if **all* of the items are `True`

```{python}
all([(lambda x:x % 2 == 1)(num) for num in L])
```

# F-strings when creating a new *class*

```{python}
class A(object):
  def __init__(self,name,age):
    self.name = name
    self.age = age
  def __repr__(self):
    return f"""
      My name is {self.name}.
      I am {self.age + 5} years old
      """

```

```{python}
name = 'Bob'
age = 15
print(A(name,age))
```
```{python}
A('Nathan', 31)
```

# Sorting

Can sort a list alphabetically.

```{python}
animals = ["cat", "dog", "cheetah", "rhino"]

sorted(animals)
sorted(animals, reverse=True)
```

Here, we have a list of animals defined by a dictionary.

```{python}
animals = [
  {'type': 'cat', 'name': 'Stephanie', 'age': 8},
  {'type': 'dog', 'name': 'Devon', 'age': 3},
  {'type': 'rhino', 'name': 'Moe', 'age': 5},
]
```
You can't sort a dictionary but you can define a `lambda` to sort by.

```{python}
sorted(animals, key = lambda animal: animal['age'])
```

If you wanted to return the oldest animal, pass in the `reverse=True` parameter and slice into the first item in the dictionary.

```{python}

sorted(animals, key = lambda animal: animal['age'], reverse=True)[0]
```

You can also use the `.sort()` method, you can do the same thing but mutating the dictionary

```{python}
animals.sort(key = lambda animal: animal['age'], reverse=True)
animals
```

# Set()

* Sets are unordered
* Set elements are unique (no duplicates)
* A set may be modified but the elements contained in the set must be of an immutable type

```{python}
s = 'quux'
list(s)
set(s)
```

```{python}
x = {'foo', 'bar', 'baz', 'foo', 'qux'}
x
```

```{python}
set('foo')
```

```{python}
x = {}
type(x)

x = set()
type(x)
```
Don’t forget that set elements must be immutable. For example, a tuple may be included in a set:

```{python}
x = {42, 'foo', (1, 2, 3), 3.14159}
x

```

But lists and dictionaries are mutable, so they can’t be set elements:

```{python eval=FALSE}
a = [1, 2, 3]
{a}

d = {'a': 1, 'b': 2}
{d}

```

```{python}
x = {'foo', 'bar', 'baz'}

len(x)

'bar' in x

'qux' in x
```

In Python, set union can be performed with the | operator:

```{python}
x1 = {'foo', 'bar', 'baz'}
x2 = {'baz', 'qux', 'quux'}
x1 | x2
```

Set union can also be obtained with the .union() method. The method is invoked on one of the sets, and the other is passed as an argument

```{python}
x1.union(x2)
```

When you use the | operator, both **operands must be sets**. The .union() method, on the other hand, will take any iterable as an argument, convert it to a set, and then perform the union.


```{python}
x1.union(('baz', 'qux', 'quux'))
```

More than two sets may be specified with either the operator or the method:

```{python}
a = {1, 2, 3, 4}
b = {2, 3, 4, 5}
c = {3, 4, 5, 6}
d = {4, 5, 6, 7}

a.union(b, c, d)


a | b | c | d
```
The resulting set contains only elements that are present in all of the specified sets.

```{python}
a = {1, 2, 3, 4}
b = {2, 3, 4, 5}
c = {3, 4, 5, 6}
d = {4, 5, 6, 7}

a.intersection(b, c, d)


a & b & c & d
```

x1.difference(x2) and x1 - x2 return the set of all elements that are in x1 but not in x2:

```{python}

x1 = {'foo', 'bar', 'baz'}
x2 = {'baz', 'qux', 'quux'}

x1.difference(x2)


x1 - x2
```

# Frozen Sets

Srozenset, which is in all respects exactly like a set, except that a frozenset is immutable. You can perform non-modifying operations on a frozenset but methods that attempt to modify a frozenset fail

# How to Use Generators and yield in Python

Have you ever had to work with a dataset so large that it overwhelmed your machine’s memory? Or maybe you have a complex function that needs to maintain an internal state every time it’s called, but the function is too small to justify creating its own class. In these cases and more, generators and the Python yield statement are here to help.

## Using Generators

Introduced with PEP 255, generator functions are a special kind of function that return a lazy iterator. These are objects that you can loop over like a list. However, unlike lists, lazy iterators do not store their contents in memory. 

This is a reasonable explanation, but would this design still work if the file is very large? What if the file is larger than the memory you have available? To answer this question, let’s assume that csv_reader() just opens the file and reads it into an array:

```{python}
def csv_reader(file_name):
    file = open(file_name)
    result = file.read().split("\n")
    return result
```


This function opens a given file and uses file.read() along with .split() to add each line as a separate element to a list. If you were to use this version of csv_reader() in the row counting code block you saw further up, then you’d get the following output: *MemoryError*

In this case, open() returns a generator object that you can lazily iterate through line by line. However, file.read().split() loads everything into memory at once, causing the *MemoryError*.

However you can turn *csv_reader()* into a generator function:

```{python}
def csv_reader(file_name):
    for row in open(file_name, "r"):
        yield row

```

This version opens a file, loops through each line, and yields each row instead of returning it.

You can also define a generator expression (also called a generator comprehension), which has a very similar syntax to list comprehensions. In this way, you can use the generator without calling a function:

```{python}
csv_gen = (row for row in open(file_name))
```

* Using **yield** will result in a generator object.
* Using **return** will result in the first line of the file only.

## Generating an Infinite Sequence

In Python, to get a finite sequence, you call range() and evaluate it in a list context:

```{python}
a = range(5)
list(a)
```

Generating an infinite sequence, however, will require the use of a generator, since your computer memory is finite:

```{python}
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

```

## Detecting Palindromes


```{python}
def is_palindrome(num):
    # Skip single-digit inputs
    # Floor division returns not the remainder like % but the whole number.
    if num // 10 == 0:
        return False
    temp = num
    reversed_num = 0

    while temp != 0:
        reversed_num = (reversed_num * 10) + (temp % 10)
        temp = temp // 10

    if num == reversed_num:
        return num
    else:
        return False
```

Don’t worry too much about understanding the underlying math in this code. Just note that the function takes an input number, reverses it, and checks to see if the reversed number is the same as the original. Now you can use your infinite sequence generator to get a running list of all numeric palindromes:

```{python eval=FALSE}
for i in infinite_sequence():
    pal = is_palindrome(i)
    if pal:
        print(pal)
```

# Understanding Generators

*yield* indicates where a value is sent back to the caller, but unlike return, you don’t exit the function afterward.

Instead, the state of the function is remembered. That way, when next() is called on a generator object (either explicitly or implicitly within a for loop), the previously yielded variable num is incremented, and then yielded again.