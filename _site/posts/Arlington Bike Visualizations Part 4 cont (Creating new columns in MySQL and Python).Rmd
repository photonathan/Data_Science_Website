---
title: "Arlington Bike Visualizations Part 2 cont (Creating new columns in MySQL and Python)"
output: github_document
---

# Oops, we need more data

Although we just finished Part 2, I'm actually working on Part 4 and realized that I need to add new columns/data to my MySQL database. This means, I need to add the automation into my python program as well as add the columns the existing rows already in my database. Yes, I could change the python code to include the new columns but this gives us an opportunity to practice how to do essentially do the same thing in both python and MySQL.


# Changes in MySQL

```{sql}
SELECT * FROM counts.counts_daily;

# Adds columns to the table
ALTER TABLE counts_daily 
ADD COLUMN year SMALLINT(4) AFTER is_weekend,
ADD COLUMN month SMALLINT(2) AFTER year,
ADD COLUMN day SMALLINT(2) AFTER month;
ALTER TABLE counts_daily;

# Turns off check so you can edit many rows
SET SQL_SAFE_UPDATES = 0;
# Assigns the Year, Month, and Day to individual columns
UPDATE counts.counts_daily SET year = Year(Date);
UPDATE counts.counts_daily SET month = Month(Date);
UPDATE counts.counts_daily SET day = Day(Date);

# Adds a column month_day which will make it easy to take the average of specific days from 2017-2019
ALTER TABLE counts_daily ADD COLUMN month_day VARCHAR(5) AFTER day;
UPDATE counts_daily SET month_day = DATE_FORMAT(date, '%m-%d') WHERE month_day is null;
```


# Changes to Python code

```{python}
def new_counts_by_day_to_sql():
    engine = create_new_engine('counts')
    # Establish connection to MySQL database before making all the API calls.
    #TODO: Add except here that will stop code if connection isn't successful
    #TODO: If no data is in the MySQL database, custom except error
    # This prevents the program from pulling today's date
    start_date = last_sql_date_counts_daily() + timedelta(days=1)
    if start_date == None:
        print('No data found in MySQL database.')
        print('Please use all_counts_to_sql() function')
        return None
    if start_date >= date.today() - timedelta(days=1):
        #TODO: throw an exception error instead of print
        print('No new data avaiable')
        return None
    end_date = start_date.replace(year = start_date.year + 1)
    if end_date >= date.today():
        end_date = date.today() - timedelta(days=1)
     ## Test db Connection##
    # Creates the parameters to drive the connection
    # Bike Arlington API only accepts query ranges of 1 year or less
    count_in_date_range_list = []   
    while end_date <= date.today() - timedelta(days=1):  
    # Hardcoded the counterID list to not stress the server
        bikeometer_id_list = ['33','30','43','24','59','56','47','48','10','20',
                           '35','57','18','3','58','61','62','38','44','14',
                           '60','5','6','42','37','27','26','8','7','51','52',
                           '45','22','21','36','34','41','9','39','16','15',
                           '54','55','31','28','11','2','25','19']
        for bikeometer_id in bikeometer_id_list:
            # Dates YYYY-MM-DD format converted to MM-DD-YYY and made into a string to search Counter API
            clean_start_date = f'{start_date.month}/{start_date.day}/{start_date.year}'
            clean_end_date = f'{end_date.month}/{end_date.day}/{end_date.year}'
            # Calls the get_count_in_date_range function and passes in hard-coded
            # parameters like the start_date, which is the first datapoint in
            # Bike Arlington server. Optimally, these would not be hardcoded  
            # make the porgram more future-proof.
            api_counts_to_list(bikeometer_id, clean_start_date, clean_end_date, count_in_date_range_list, interval='d')
        # If end date is yesterday's date, congratulations, you pulled all available dates
        # We won't pull today's date in case the data has not been uploaded to their servers yet
        if end_date == date.today() - timedelta(days=1):
            break                
        # Adds a year to start date and end date
        start_date = start_date.replace(year = start_date.year + 1)
        end_date = end_date.replace(year = end_date.year + 1)
        # If end date is after yesterday's date, set the end date to yesterdayand pull the data one last time
        if end_date >= date.today():
            end_date = date.today() - timedelta(days=1)    
    columns = ('bikeometer_id', 'date', 'direction', 'count', 'is_weekend', 'year', 'month', 'day', 'month_day')
    df = pd.DataFrame(count_in_date_range_list, columns=columns)
    # Replaces table counts, use if_exists='append' to insert new values into the table
    df.to_sql('counts_daily', con=engine, index=False, if_exists='append')
    # Reads the table
    #df2 = pd.read_sql('counters', con=engine)
    with engine.connect() as con:
        date_list = con.execute('SELECT MAX(Date) FROM counts_daily')
        for day in date_list:
            last_day = day[0]
            print(f'The newest date in counts_daily is {last_day}')
    # Do we need engine.dispose?
    engine.dispose()
```

